'use strict'

var User = require('../models/user.js');
var bcrypt = require('bcrypt-nodejs');
var jwt = require('../services/jwt');
var mongoosePaginate = require('mongoose-pagination');
var fs = require('fs');
var path = require('path');

// testing /home route
function home(req, res){
    res.status(200).send({
      message: 'Server OK over UserJS Controller'
    });
}
// testing /pruebas route
function pruebas(req, res){
    console.log(req.body);
    res.status(200).send({
      message: 'Testing path /pruebas/ on server over UserJS Controller'
    });
}
//
// Saves an user to db
//
function saveUser(req, res){
  var params = req.body;
  var user = new User();

  if(params.name && params.surname && params.nick && params.email && params.password){
    user.name = params.name;
    user.surname = params.surname;
    user.nick = params.nick;
    user.email = params.email;
    user.role = 'USER_ROLE';
    user.image = null;

    // Duplicated-Users control
    User.find({ $or: [ // 'find' only, will check every User in our db to check if there is a duplicate
                          {email: user.email.toLowerCase()},
                          {nick: user.nick.toLowerCase()}
                        ]}).exec((err, users) => {
                          if(err) return res.status(400).send({message: 'Error en la petición de usuarios'});

                          if(users && users.length >= 1){
                            return res.status(400).send({message: 'El usuario que intenta registrar ya existe'});
                          }else{
                            // Password cypher by bcrypt lib
                            bcrypt.hash(params.password, null, null, (err, hash)=>{
                              user.password = hash;
                              user.save((err, userStored) =>{
                                if(err) return res.status(400).send({message: 'Error al guardar el usuario'});

                                if(userStored){
                                  res.status(200).send({user: userStored});
                                }else{
                                  res.status(400).send({message: 'No se ha registrado el usuario'});
                                }
                              });
                            });
                          }
                        });
  }else{
    res.status(400).send({message: 'Error. Envia todos los campos necesarios'});
  }
}

//
// Login function (just compare email and bcrypted passwords)
//
function loginUser(req,res){
  var params = req.body;
  var email = params.email;
  var password = params.password;

  User.findOne({email: email}, (err, user)=> { // findOne means that we ONLY wants 1 user
    if(err) return res.status(400).send({message: 'Error en la petición'}); // if we got an error, throw a 400 status

    if(user){
      bcrypt.compare(password, user.password, (err, check)=>{
        if(check){
          console.log("Usuario loggeado");
          if(params.gettoken){ // if we request 'gettoken' via post, we return a token generated by service/jwt.js
            return res.status(200).send({
              token: jwt.createToken(user) // creating token, passing our FOUND user
            })
          }else{ // if we don't request a token, then
            user.password = undefined; // undefine our password due to security
            return res.status(200).send({user}); // send our user (without password)
          }
        }else{
          // error cause password doesn't match
          return res.status(400).send({message: 'El usuario no se ha podido identificar'});
        }
      });
    }else{
      // error cause user not found, by the way, we return the same message as above due to security (if our client try to bruteforce 'email' field, he will never know if a user exists)
      return res.status(400).send({message: 'El usuario no se ha podido identificar'});
    }
  });
}

// Get a user by an Id
function getUser(req, res){
  var userId = req.params.id;

  User.findById(userId, (err, user) =>{
      if(err) {
        return res.status(500).send({message: 'Error en tu petición de usuario'});
        console.log("Error en la búsqueda del usuario");
      }
      if(!user) {
        return res.status(404).send({message: 'Error en tu petición de usuario'});
        console.log("No se ha encontrado el usuario a buscar");
      }
      return res.status(200).send({user});
  });
}

// Get a Users paginated list
function getUsers(req, res){
  // we receive over URL a number of pages
  var identity_user_id = req.user.sub;
  var page = 1;
  if(req.params.page){
    page = req.params.page;
  }
  var itemsPerPage = 5;

  User.find().sort('_id').paginate(page, itemsPerPage, (err, users, total)=>{
    if(err) return res.status(500).send({message: 'Error en la petición'});
    if(!users) return res.status(404).send({message: 'No hay usuarios en la plataforma'});

    return res.status(200).send({
      users,
      total,
      pages: Math.ceil(total/itemsPerPage) // we round our total of users / users per Page and send it over json
    });
  });
}

// editing an existing user

function updateUser(req, res){
  var userId = req.params.id;
  var update = req.body;

  // we delete the password property because we need another function to do this with more parameters
  delete update.password;

  if(userId != req.user.sub){ // if the user requesting the edit differs from the logged user, then we kick him out
      return res.status(403).send({message: 'No tienes permisos para la acción'});
  }
  User.findByIdAndUpdate(userId, update, {new:true}, (err, userUpdated)=>{
    if(err) return res.status(500).send({message: 'Ha ocurrido un error en tu petición'});
    if(!userUpdated) return res.status(500).send({message: 'No se ha podido actualizar la información'});

    return res.status(200).send({user: userUpdated}); // we return our updated user
  });

}

// function to upload images to our platform

function uploadImage(req, res){

  var userId = req.params.id;

  if(req.files){

    var file_path = req.files.image.path;
    var file_split = file_path.split('\\');
    var file_name = file_split[2]; // we save only our filename
    var ext_split = file_name.split('\.'); // we split our filename to get extension
    var file_ext = ext_split[1]; // we save the extension of our file
        if(userId != req.user.sub){
          return removeFilesOfUploads(res, file_path, 'No tienes permisos para actualizar lo que pediste');
        }
        if(file_ext == 'png' || file_ext == 'jpg' || file_ext == 'jpeg' || file_ext == 'gif'){ // lets check our extension, we are allowing only this
            // we got everything k ! so we change our data on db
            User.findByIdAndUpdate(userId, {image: file_name}, {new:true}, (err, userUpdated)=>{
              if(err) return res.status(500).send({message: 'Ha ocurrido un error en tu petición'});
              if(!userUpdated) return res.status(500).send({message: 'No se ha podido actualizar la información'});

              return res.status(200).send({user: userUpdated}); // we return our updated user
            });

        }else{
            return removeFilesOfUploads(res, file_path, 'La extensión no es válida');
        }
  }else{
    return res.status(500).send({message: 'No se han subido archivos'}); // if we don't receive anything, then we throw a message
  }
}


function removeFilesOfUploads(res, file_path, message){ // function to remove files, we need to pass res, a file path to delete and a string with a message
    fs.unlink(file_path, (err) =>{
      return res.status(500).send({message: message});
    });
}

function getImageFile(req, res){ // this function is to get an image
  var image_file = req.params.imageFile;
  var path_file = './uploads/users/'+image_file;

  fs.exists(path_file, (exists) =>{
    if(exists){
      res.sendFile(path.resolve(path_file));
    }else{
      res.status(404).send({message: 'Imagen no encontrada'});
    }
  });

}
// export our modules to user routes
module.exports = {
  home,
  pruebas,
  saveUser,
  loginUser,
  getUser,
  getUsers,
  updateUser,
  uploadImage,
  getImageFile
}
